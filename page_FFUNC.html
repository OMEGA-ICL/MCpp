<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MC++: Construction, Manipulation and Evaluation of Factorable Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=HTML-CSS/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MC++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_FFUNC.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Construction, Manipulation and Evaluation of Factorable Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Benoit Chachuat &amp; OMEGA Research Group (<a href="http://www3.imperial.ac.uk/environmentenergyoptimisation">http://www3.imperial.ac.uk/environmentenergyoptimisation</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>No known bugs.</dd></dl>
<p>Originally introduced by McCormick [McCormick, 1976] for the development of a convex/concave relaxation arithmetic, <b>factorable functions</b> cover an extremely inclusive class of functions which can be represented finitely on a computer by means of a code list or a computational graph involving atom operations. These are typically unary and binary operations within a library of atom operators, which can be based for example on the C-code library <code>math.h</code>. Besides convex/concave relaxations, factorable functions find applications in automatic differentiation (AD) [Naumann, 2009] as well as in interval analysis [Moore <em>et al.</em>, 2009] and Taylor model arithmetic [Neumaier, 2002].</p>
<p>Factorable functions can be represented using <b>directed acyclic graphs (DAGs)</b>, whose nodes are subexpressions and whose directed edges are computational flows [Schichl &amp; Neumaier, 2005]. Compared to tree-based representations, DAGs offer the essential advantage of more accurately handling the influence of subexpressions shared by several functions during evaluation.</p>
<p>The classes <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a>, <a class="el" href="classmc_1_1FFVar.html" title="Class defining variables in a factorable function. ">mc::FFVar</a> and <a class="el" href="classmc_1_1FFOp.html" title="Class defining operations in a factorable function. ">mc::FFOp</a> defined in <code><a class="el" href="ffunc_8hpp_source.html">ffunc.hpp</a></code> implement such a DAG construction for factorable functions. They also provide a basis for their manipulation, including differentiation and Taylor expansion, as well as their evaluation, in particular with the types <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a>, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a>, <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation. ">mc::TVar</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> of MC++.</p>
<h1><a class="anchor" id="sec_FFUNC_dag"></a>
How Do I Construct the DAG of a Factorable Function?</h1>
<p>For illustration, suppose we want to construct a DAG for the factorable function \({\bf f}:\mathbb{R}^4\to\mathbb{R}^2\) defined by </p><p class="formulaDsp">
\begin{align*} {\bf f} = \left(\begin{array}{c} x_2x_3-x_0\\ x_0(\exp(x_2x_3)+3.0)^4)+x_1\end{array}\right) \end{align*}
</p>
<p>The constructions require the header file <code><a class="el" href="ffunc_8hpp_source.html">ffunc.hpp</a></code> to be included:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ffunc.hpp&quot;</span></div></div><!-- fragment --><p>An environment <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> is first defined for recording the factorable function DAG. All four variables <a class="el" href="classmc_1_1FFVar.html" title="Class defining variables in a factorable function. ">mc::FFVar</a> participating in that function are then defined in the enviornment using the method <a class="el" href="group__FFunc.html#ga01b248e64b08d4a73bcb883aa13b2d77" title="Attach variable to DAG *dag. ">mc::FFVar::set</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classmc_1_1FFGraph.html">mc::FFGraph</a> DAG;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NX = 4;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> X[NX];</div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;NX; i++ ) X[i].<span class="keyword">set</span>( &amp;DAG );</div></div><!-- fragment --><p>The two components of the factorable function can be defined next:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NF = 2;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> F[NF]</div><div class="line">  = { X[2]*X[3]-X[0],</div><div class="line">      X[0]*pow(exp(X[2]*X[3])+3.,4)+X[1] };</div><div class="line">std::cout &lt;&lt; DAG;</div></div><!-- fragment --><p>The last line displays the following information about the factorable function DAG:</p>
<pre class="fragment">    DAG VARIABLES:
      X0     =&gt; { Z1 Z7 }
      X1     =&gt; { Z8 }
      X2     =&gt; { Z0 }
      X3     =&gt; { Z0 }

    DAG INTERMEDIATES:
      Z0    &lt;=  X2 * X3              =&gt; { Z1 Z2 }
      Z1    &lt;=  Z0 - X0              =&gt; { }
      Z2    &lt;=  EXP( Z0 )            =&gt; { Z4 }
      Z4    &lt;=  Z2 + Z3              =&gt; { Z6 }
      Z6    &lt;=  POW( Z4, Z5 )        =&gt; { Z7 }
      Z7    &lt;=  X0 * Z6              =&gt; { Z8 }
      Z8    &lt;=  X1 + Z7              =&gt; { }
      Z5    &lt;=  4(I)                 =&gt; { Z6 }
      Z3    &lt;=  3(D)                 =&gt; { Z4 }
</pre><p>Observe that 9 auxiliary variables, \(z_0,\ldots,z_8\), have been created in the DAG, which correspond to the various unary and binary operations in the factorable function expression, as well as the (integer or real) participating constants. Observe, in particular, that the common sub-expression \(x_2x_3\) is detected here; that is, the intermediate \(z_0\) is reused to obtain both subsequent auxiliary variables \(z_1\) and \(z_2\).</p>
<p>At this point, the member function <a class="el" href="classmc_1_1FFGraph.html#a1030db7caae73e8918de0e20ea3acf2e" title="Extract list of operations corresponding to nDep dependents in array pDep ">mc::FFGraph::subgraph</a> can be used to generate the subgraph of a DAG corresponding to a given subset of dependent variables. This function returns a list of const pointers <a class="el" href="classmc_1_1FFOp.html" title="Class defining operations in a factorable function. ">mc::FFOp</a>* to the operations participating in the subgraph in order of appearance, which can then be displayed using the member function <a class="el" href="classmc_1_1FFGraph.html#a847e27ca90bbe6f625bf8ceb2ed7f800" title="Output list of nodes in Ops to os ">mc::FFGraph::output</a>:</p>
<div class="fragment"><div class="line">DAG.output( DAG.subgraph( NF, F ) );</div><div class="line">DAG.output( DAG.subgraph( 1, &amp;F[0] ) );</div></div><!-- fragment --><p>The member function FFGraph::subgraph Here, the first line generates and displays a subgraph of both components of \({\bf f}\), whereas the second line generates and displays a subgraph of the first component \(f_0\) only:</p>
<pre class="fragment">    FACTORS IN SUBGRAPH:
      X2    &lt;=  VARIABLE
      X3    &lt;=  VARIABLE
      Z0    &lt;=  X2 * X3
      X0    &lt;=  VARIABLE
      Z1    &lt;=  Z0 - X0
      X1    &lt;=  VARIABLE
      Z2    &lt;=  EXP( Z0 )
      Z3    &lt;=  3(D)
      Z4    &lt;=  Z2 + Z3
      Z5    &lt;=  4(I)
      Z6    &lt;=  POW( Z4, Z5 )
      Z7    &lt;=  X0 * Z6
      Z8    &lt;=  X1 + Z7

    FACTORS IN SUBGRAPH:
      X2    &lt;=  VARIABLE
      X3    &lt;=  VARIABLE
      Z0    &lt;=  X2 * X3
      X0    &lt;=  VARIABLE
      Z1    &lt;=  Z0 - X0
</pre><p>The obtained subgraphs can also be depicted using the (open source) graph plotting program <a href="http://www.graphviz.org/">DOT</a>. The dot files <code>F.dot</code> and <code>F1.dot</code> can be generated for both subgraphs as follows [which requires the header file <code>fstream.h</code>]:</p>
<div class="fragment"><div class="line">std::ofstream o_F( <span class="stringliteral">&quot;F.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( NF, F, o_F );</div><div class="line">o_F.close();</div><div class="line"></div><div class="line">std::ofstream o_F0( <span class="stringliteral">&quot;F0.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( 1, F, o_F0 );</div><div class="line">o_F0.close();</div></div><!-- fragment --><p>The graphs can be visualized, e.g., after generating SVG files using the command line as:</p>
<pre class="fragment">    $ dot -Tsvg -O F.dot;  display F.dot.svg
    $ dot -Tsvg -O F0.dot; display F0.dot.svg
</pre><center><table  border="0">
<tr>
<td><h3>Graph for file <code>F.dot</code></h3>
<div class="image">
<img src="F.png" alt="F.png"/>
</div>
 </td><td><h3>Graph for file <code>F0.dot</code></h3>
<div class="image">
<img src="F0.png" alt="F0.png"/>
</div>
  </td></tr>
</table>
</center><h1><a class="anchor" id="sec_FFUNC_FADBAD"></a>
How Do I Obtain the DAG of a Factorable Function's Derivatives?</h1>
<p>Derivatives of a factorable function in <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> can be obtained with the methods <a class="el" href="classmc_1_1FFGraph.html#a72452bac850450e4ae910d29047cedef" title="Expand DAG with derivatives of dependents vDep with respect to independents vIndep using fadbad::F (d...">mc::FFGraph::FAD</a> and <a class="el" href="classmc_1_1FFGraph.html#acf6512e382e7956ad3c6ba34738b2c6f" title="Expand DAG with derivatives of dependents vDep with respect to independents vIndep using fadbad::B –...">mc::FFGraph::BAD</a>, which implement the forward and reverse mode of automatic differentiation (AD), respectively. It should be noted that <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> does not implement these AD methods per se, but uses the classes fadbad::F and fadbad::B as part of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a>.</p>
<p>In the forward mode of AD, for instance, entries of the Jacobian matrix of the factorable function \(f\) considered in the previous section can be added to the DAG as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a>* dFdX_FAD = DAG.FAD( NF, F, NX, X );</div><div class="line">std::cout &lt;&lt; DAG;</div></div><!-- fragment --><p>The last line displays the following information about the DAG of the factorable function and its Jacobian:</p>
<pre class="fragment">    DAG VARIABLES:
      X0     =&gt; { Z1 Z7 Z17 Z18 }
      X1     =&gt; { Z8 }
      X2     =&gt; { Z0 Z10 }
      X3     =&gt; { Z0 Z9 }

    DAG INTERMEDIATES:
      Z0    &lt;=  X2 * X3              =&gt; { Z1 Z2 }
      Z1    &lt;=  Z0 - X0              =&gt; { }
      Z2    &lt;=  EXP( Z0 )            =&gt; { Z4 Z9 Z10 }
      Z4    &lt;=  Z2 + Z3              =&gt; { Z6 Z12 }
      Z6    &lt;=  POW( Z4, Z5 )        =&gt; { Z7 }
      Z7    &lt;=  X0 * Z6              =&gt; { Z8 }
      Z8    &lt;=  X1 + Z7              =&gt; { }
      Z9    &lt;=  X3 * Z2              =&gt; { Z15 }
      Z10   &lt;=  X2 * Z2              =&gt; { Z16 }
      Z12   &lt;=  POW( Z4, Z11 )       =&gt; { Z14 }
      Z14   &lt;=  Z12 * Z13            =&gt; { Z15 Z16 }
      Z15   &lt;=  Z9 * Z14             =&gt; { Z17 }
      Z16   &lt;=  Z10 * Z14            =&gt; { Z18 }
      Z17   &lt;=  X0 * Z15             =&gt; { }
      Z18   &lt;=  X0 * Z16             =&gt; { }
      Z11   &lt;=  3(I)                 =&gt; { Z12 }
      Z5    &lt;=  4(I)                 =&gt; { Z6 }
      Z19   &lt;=  -1(D)                =&gt; { }
      Z20   &lt;=  0(D)                 =&gt; { }
      Z21   &lt;=  1(D)                 =&gt; { }
      Z3    &lt;=  3(D)                 =&gt; { Z4 }
      Z13   &lt;=  4(D)                 =&gt; { Z14 }
</pre><p>Observe that 13 extra auxiliary variables, \(z_9,\ldots,z_{21}\), have been created in the DAG after the application of forward AD. The function mc:FFGraph::FAD returns a const array, whose entries correspond to \(\frac{\partial f_i}{\partial x_j}\) of the Jacobian matrix of \(f\) in the DAG, ordered column-wise as \(\frac{\partial f_1}{\partial x_1},\ldots,\frac{\partial f_1}{\partial x_n},\frac{\partial f_2}{\partial x_1},\ldots,\frac{\partial f_2}{\partial x_n},\ldots\). To prevent memory leaks, this const array should be deleted before becoming out of scope.</p>
<p>As previously, subgraphs can be constructed for all or part of the derivatives, and dot file can be generated for these subgraphs too, e.g.:</p>
<div class="fragment"><div class="line">std::ofstream o_dFdX_FAD( <span class="stringliteral">&quot;dFdX_FAD.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( NX*NF, dFdX_FAD, o_dFdX_FAD );</div><div class="line">o_dFdX_FAD.close();</div><div class="line"></div><div class="line">std::ofstream o_dF1dX3_FAD( <span class="stringliteral">&quot;dF1dX3_FAD.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( 1, &amp;dFdX_FAD[NX+3], o_dF1dX3_FAD );</div><div class="line">o_dF1dX3_FAD.close();</div><div class="line"></div><div class="line"><span class="keyword">delete</span>[] dFdX_FAD;</div></div><!-- fragment --><p>The first subgraph created above corresponds to both components of the factorable function \(f\) as well as all eight component of its Jacobian matrix \(\frac{\partial {\bf f}}{\partial {\bf x}}\); the second subgraph is for the Jacobian element \(\frac{\partial f_1}{\partial x_3}\). The corresponding graphs are shown below.</p>
<center><table  border="0">
<tr>
<td><h3>Graph for file <code>dFdX_FAD.dot</code> (forward AD)</h3>
<div class="image">
<img src="dFdX_FAD.png" alt="dFdX_FAD.png"/>
</div>
 </td><td><h3>Graph for file <code>dF1dX3_FAD.dot</code> (forward AD)</h3>
<div class="image">
<img src="dF1dX3_FAD.png" alt="dF1dX3_FAD.png"/>
</div>
  </td></tr>
</table>
</center><p>The backward (or adjoint) method of AD can be applied in a likewise manner using the method <a class="el" href="classmc_1_1FFGraph.html#acf6512e382e7956ad3c6ba34738b2c6f" title="Expand DAG with derivatives of dependents vDep with respect to independents vIndep using fadbad::B –...">mc::FFGraph::BAD</a> instead of mc::FFGRAPH::FAD, everything else being the same.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a>* dFdX = DAG.BAD( NF, F, NX, X );</div><div class="line"></div><div class="line">std::ofstream o_dFdX_BAD( <span class="stringliteral">&quot;dFdX_BAD.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( NX*NF, dFdX_BAD, o_dFdX_BAD );</div><div class="line">o_dFdX_BAD.close();</div><div class="line"></div><div class="line">std::ofstream o_dF1dX3_BAD( <span class="stringliteral">&quot;dF1dX3_BAD.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( 1, &amp;dFdX_BAD[NX+3], o_dF1dX3_BAD );</div><div class="line">o_dF1dX3_BAD.close();</div><div class="line"></div><div class="line"><span class="keyword">delete</span>[] dFdX_BAD;</div></div><!-- fragment --><p>The corresponding graphs are shown below. Note that the reverse mode leads to a DAG of the Jacobian matrix with 10 operations (+,*,pow,exp) only, whereas the forward mode needs 12 operations.</p>
<center><table  border="0">
<tr>
<td><h3>Graph for file <code>dFdX_BAD.dot</code> (reverse AD)</h3>
<div class="image">
<img src="dFdX_BAD.png" alt="dFdX_BAD.png"/>
</div>
 </td><td><h3>Graph for file <code>dF1dX3_BAD.dot</code> (reverse AD)</h3>
<div class="image">
<img src="dF1dX3_BAD.png" alt="dF1dX3_BAD.png"/>
</div>
  </td></tr>
</table>
</center><p>The class <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> also supports sparse derivatives, both in forward and backward modes, as well as directional derivatives in forward mode.</p>
<h1><a class="anchor" id="sec_FFUNC_eval"></a>
How Do I Evaluate the DAG of a Factorable Function in a Given Arithmetic?</h1>
<p>Having created the DAG of a factorable function or its derivatives, one can evaluate these functions in any arithmetic implemented in MC++ using the method <a class="el" href="classmc_1_1FFGraph.html#a5b9f249967895fe07fc33c45d23fe2c2" title="Evaluate the dependents in vDep in U arithmetic for the variable values specified in vVar – This fun...">mc::FFGraph::eval</a>.</p>
<p>Coming back to our initial example, suppose that we want to compute interval bounds on the first-order derivatives of the factorable function </p><p class="formulaDsp">
\begin{align*} {\bf f} = \left(\begin{array}{c} x_2x_3-x_0\\ x_0(\exp(x_2x_3)+3.0)^4)+x_1\end{array}\right) \end{align*}
</p>
<p> in the direction \((0,1,1,0)\), with \(x_0\in[0,0.5]\), \(x_1\in[1,2]\), \(x_2\in[-1,-0.8]\), and \(x_3\in[0.5,1]\).</p>
<p>For simplicity, the default interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> of MC++ is used here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ffunc.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;interval.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html">mc::Interval</a> I;</div></div><!-- fragment --><p>A DAG of the directional derivatives of \(f\) is constructed first:</p>
<div class="fragment"><div class="line"><span class="comment">// DAG environment</span></div><div class="line"><a class="code" href="classmc_1_1FFGraph.html">mc::FFGraph</a> DAG;</div><div class="line"></div><div class="line"><span class="comment">// Independent variables and derivative direction</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NX = 4;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> X[NX], D[NX] = { 0., 1., 1., 0. };</div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;NX; i++ ) X[i].<span class="keyword">set</span>( &amp;DAG );</div><div class="line"></div><div class="line"><span class="comment">// Dependent variables</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NF = 2;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> F[NF]</div><div class="line">  = { X[2]*X[3]-X[0],</div><div class="line">      X[0]*pow(exp(X[2]*X[3])+3.,4)+X[1] };</div><div class="line"></div><div class="line"><span class="comment">// DAG of second-order derivatives</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a>* dFdXdir = DAG.<a class="code" href="classmc_1_1FFGraph.html#a72452bac850450e4ae910d29047cedef">FAD</a>( NF, F, NX, X, D );</div></div><!-- fragment --><p>In a second step, the DAG of directional derivatives is evaluated in real-arithmetic as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// Evaluation in interval arithmetic</span></div><div class="line">I IX[NX] = { I(0,0.5), I(1,2), I(-1,-0.8), I(0.5,1) }, IdFdXdir[NF];</div><div class="line">DAG.<a class="code" href="classmc_1_1FFGraph.html#a5b9f249967895fe07fc33c45d23fe2c2">eval</a>( NF, dFdXdir, IdFdXdir, NX, X, IX );</div><div class="line"></div><div class="line"><span class="comment">// Display results</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;NF; i++ )</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  dF(&quot;</span>&lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)dX·D = &quot;</span> &lt;&lt; IdFdXdir[i] &lt;&lt; std::endl;</div></div><!-- fragment --><p>The DAG evaluation can be carried out in sparse Chebyshev model arithmetic likewise:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;scmodel.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1SCModel.html">mc::SCModel&lt;I&gt;</a> SCM;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1SCVar.html">mc::SCVar&lt;I&gt;</a> SCV;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Evaluation in 3rd-order Chebyshev model arithmetic</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> ORD = 3;</div><div class="line">SCM CMenv( ORD );</div><div class="line">SCV CMX[NX], CMdFdXdir[NF];</div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;NX; i++ ) CMX[i].<span class="keyword">set</span>( &amp;CMenv, i, IX[i] );</div><div class="line">DAG.<a class="code" href="classmc_1_1FFGraph.html#a5b9f249967895fe07fc33c45d23fe2c2">eval</a>( NF, dFdXdir, CMdFdXdir, NX, X, CMX );</div><div class="line"></div><div class="line"><span class="comment">// Display results</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;NF; i++ )</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  dF(&quot;</span>&lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)dX·D = &quot;</span> &lt;&lt; CMdFdXdir[i] &lt;&lt; std::endl;</div></div><!-- fragment --><p>These evaluations produce the following results:</p>
<h3>Evaluation in Interval Arithmetic</h3>
<pre class="fragment">  dF(0)dX·D = [  5.00000e-01 :  1.00000e+00 ]
  dF(1)dX·D = [  1.00000e+00 :  6.72863e+01 ]
</pre><h3>Evaluation in Taylor Model Arithmetic</h3>
<pre class="fragment">  dF(0)dX·D = 
     7.50000e-01   
     2.50000e-01   T1[3] 
       R     =  [  0.00000e+00 :  0.00000e+00 ]
       B     =  [  5.00000e-01 :  1.00000e+00 ]

  dF(1)dX·D = 
     1.71660e+01   
     1.61660e+01   T1[0] 
     1.73038e+00   T1[2] 
     3.45209e-01   T1[3] 
     1.73038e+00   T1[0] T1[2] 
     3.45209e-01   T1[0] T1[3] 
     5.09515e-01   T1[2] T1[3] 
     5.64787e-02   T2[2] 
    -3.95484e-01   T2[3] 
     5.09515e-01   T1[0] T1[2] T1[3] 
     5.64787e-02   T1[0] T2[2] 
    -3.95484e-01   T1[0] T2[3] 
    -5.04161e-02   T1[2] T2[3] 
     3.06189e-02   T2[2] T1[3] 
     1.49579e-03   T3[2] 
     4.80200e-02   T3[3] 
       R     =  [ -1.87089e-01 :  1.87089e-01 ]
       B     =  [  1.00000e+00 :  3.91087e+01 ]
</pre><h1><a class="anchor" id="sec_FFUNC_TAD"></a>
How Do I Obtain the DAG of the Taylor Expansion of ODE solutions?</h1>
<p>Consider a dynamic system of the form </p><p class="formulaDsp">
\begin{align*} \dot{\bf x}(t,{\bf p}) \;=\; {\bf f}({\bf x}(t,{\bf p}),{\bf p})\,, \end{align*}
</p>
<p> where \({\bf x} \in \mathbb{R}^{n_x}\) denotes the state variables, and \({\bf p} \in \mathbb{R}^{n_p}\) a set of (time-invariant) parameters. Assuming that the right-hand side function \({\bf f}\) is sufficiently often continuously differentiable on \(\mathbb{R}^{n_x}\times\mathbb{R}^{n_p}\), a \(q\)th-order Taylor expansion in time of the ODE solutions \(x(\cdot,{\bf p})\) at a given time \(t\) reads: </p><p class="formulaDsp">
\begin{align*} {\bf x}(t+h,{\bf p}) \;=\; \sum_{i=0}^q h^i {\boldsymbol\phi}_i({\bf x}(t,{\bf p})) + \cal{O}(h^{s+1}) \,, \end{align*}
</p>
<p> where \({\boldsymbol\phi}_0,\ldots,{\boldsymbol\phi}_q\) denote the Taylor coefficients of the solution, defined recursively as </p><p class="formulaDsp">
\begin{align*} {\boldsymbol\phi}_0({\bf x},{\bf p}) \;:=\; {\bf x} \qquad \text{and} \qquad {\boldsymbol\phi}_i({\bf x},{\bf p}) \;:=\; \frac{1}{i} \frac{\partial{\boldsymbol\phi}_{i-1}}{\partial {\bf x}}({\bf x},{\bf p})\, {\bf f}({\bf x},{\bf p}) \quad\text{for $i\geq 1$} \,. \end{align*}
</p>
<p> DAGs for these Taylor coefficients can be generated using the method <a class="el" href="classmc_1_1FFGraph.html#a9d374d0fc19ef72b2e2e0dba463d9b62" title="Expand DAG with Taylor coefficients of dependents vDep with respect to independents vIndep using fadb...">mc::FFGraph::TAD</a>, which relies upon the class fadbad::T of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a>.</p>
<p>As a simple illustrative example, consider the scalar linear ODE \(\dot{x}(t) = x(t)\), whose solutions are given by \(x(t+h) = \exp(h)x(t)\). Accordingly, the desired Taylor coefficients are: </p><p class="formulaDsp">
\begin{align*} \phi_i({\bf x}) \;:=\; \frac{1}{i!}x \quad\text{for all $i\geq 0$} \,. \end{align*}
</p>
<p> A DAG of these Taylor coefficients can be generated by <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classmc_1_1FFGraph.html">mc::FFGraph</a> DAG;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> T( &amp;DAG );</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> X( &amp;DAG ); </div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> F = X;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> NTE = 10;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a>* F_TAD = DAG.<a class="code" href="classmc_1_1FFGraph.html#a9d374d0fc19ef72b2e2e0dba463d9b62">TAD</a>( NTE, 1, &amp;F, 1, &amp;X, &amp;T );</div><div class="line">std::cout &lt;&lt; DAG;</div><div class="line"></div><div class="line">DAG.<a class="code" href="classmc_1_1FFGraph.html#a847e27ca90bbe6f625bf8ceb2ed7f800">output</a>( DAG.subgraph( NTE+1, F_TAD ) );</div><div class="line">std::ofstream o_TAD( <span class="stringliteral">&quot;FTE.dot&quot;</span>, std::ios_base::out );</div><div class="line">DAG.dot_script( NTE+1, F_TAD, o_TAD );</div><div class="line">o_TAD.close();</div><div class="line"></div><div class="line"><span class="keyword">delete</span>[] F_TAD;</div></div><!-- fragment --><p>The resulting DAG of the Taylor coefficients up to order 10 is shown below.</p>
<center><table  border="0">
<tr>
<td><pre class="fragment">DAG VARIABLES:
  X0     =&gt; { Z1 }

DAG INTERMEDIATES:
  Z1    &lt;=  X0 * Z0       =&gt; { Z3 }
  Z3    &lt;=  Z1 * Z2       =&gt; { Z5 }
  Z5    &lt;=  Z3 * Z4       =&gt; { Z7 }
  Z7    &lt;=  Z5 * Z6       =&gt; { Z9 }
  Z9    &lt;=  Z7 * Z8       =&gt; { Z11 }
  Z11   &lt;=  Z9 * Z10      =&gt; { Z13 }
  Z13   &lt;=  Z11 * Z12     =&gt; { Z15 }
  Z15   &lt;=  Z13 * Z14     =&gt; { Z17 }
  Z17   &lt;=  Z15 * Z16     =&gt; { }
  Z16   &lt;=  0.1(D)        =&gt; { Z17 }
  Z14   &lt;=  0.111111(D)   =&gt; { Z15 }
  Z12   &lt;=  0.125(D)      =&gt; { Z13 }
  Z10   &lt;=  0.142857(D)   =&gt; { Z11 }
  Z8    &lt;=  0.166667(D)   =&gt; { Z9 }
  Z6    &lt;=  0.2(D)        =&gt; { Z7 }
  Z4    &lt;=  0.25(D)       =&gt; { Z5 }
  Z2    &lt;=  0.333333(D)   =&gt; { Z3 }
  Z0    &lt;=  0.5(D)        =&gt; { Z1 }

FACTORS IN SUBGRAPH:
  X0    &lt;=  VARIABLE
  Z0    &lt;=  0.5(D)
  Z1    &lt;=  X0 * Z0
  Z2    &lt;=  0.333333(D)
  Z3    &lt;=  Z1 * Z2
  Z4    &lt;=  0.25(D)
  Z5    &lt;=  Z3 * Z4
  Z6    &lt;=  0.2(D)
  Z7    &lt;=  Z5 * Z6
  Z8    &lt;=  0.166667(D)
  Z9    &lt;=  Z7 * Z8
  Z10   &lt;=  0.142857(D)
  Z11   &lt;=  Z9 * Z10
  Z12   &lt;=  0.125(D)
  Z13   &lt;=  Z11 * Z12
  Z14   &lt;=  0.111111(D)
  Z15   &lt;=  Z13 * Z14
  Z16   &lt;=  0.1(D)
  Z17   &lt;=  Z15 * Z16
</pre> </td><td><h3>Graph for file <code>TFE.dot</code></h3>
<div class="image">
<img src="FTE.png" alt="FTE.png"/>
</div>
  </td></tr>
</table>
</center><p>In turn, the resulting DAG of Taylor coefficients may be differentiated using <a class="el" href="classmc_1_1FFGraph.html#a72452bac850450e4ae910d29047cedef" title="Expand DAG with derivatives of dependents vDep with respect to independents vIndep using fadbad::F (d...">mc::FFGraph::FAD</a> or <a class="el" href="classmc_1_1FFGraph.html#acf6512e382e7956ad3c6ba34738b2c6f" title="Expand DAG with derivatives of dependents vDep with respect to independents vIndep using fadbad::B –...">mc::FFGraph::BAD</a>, or evaluated in any compatible arithmetic as explained next.</p>
<h1><a class="anchor" id="sec_FFUNC_err"></a>
What Errors Can I Encounter While Creating or Manipulating the DAG of a Factorable Function?</h1>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, a class object of type <a class="el" href="classmc_1_1FFGraph_1_1Exceptions.html" title="Exceptions of mc::FFGraph. ">mc::FFGraph::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during the creation/manipulation of a DAG, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, the execution will abort.</p>
<p>Possible errors encountered during the creation/manipulation of a DAG are:</p>
<a class="anchor" id=""></a>
<table  border="1">
<caption><em>Errors during the Creation/Manipulation of a DAG</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Invalid DAG pointer passed for initilization of a variable </td></tr>
<tr>
<th><code>2</code> </th><td>Operation between variables linked to different DAGs </td></tr>
<tr>
<th><code>3</code> </th><td>Empty intersection between constant variables </td></tr>
<tr>
<th><code>4</code> </th><td>Missing independent variable during subgraph evaluation </td></tr>
<tr>
<th><code>5</code> </th><td>Exception thrown during DAG evaluation </td></tr>
<tr>
<th><code>-1</code> </th><td>Internal Error </td></tr>
<tr>
<th><code>-33</code> </th><td>Feature not yet implemented in <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> </td></tr>
</table>
<p>Further exceptions can be thrown by the underlying arithmetic used for the evaluation of a DAG.</p>
<h1><a class="anchor" id="sec_FFUNC_refs"></a>
References</h1>
<ul>
<li>McCormick, G. P., <a href="http://dx.doi.org/10.1007/BF01580665">Computability of global solutions to factorable nonconvex programs: Part I. Convex underestimating problems</a>, <em>Mathematical Programming</em>, <b>10</b>(2):147-175, 1976</li>
<li>Moore, R.E., M.J. Cloud, R.B. Kearfott, <em><a href="http://books.google.co.uk/books/about/Introduction_to_interval_analysis.html?id=tT7ykKbqfEwC&amp;redir_esc=y">"Introduction to Interval Analysis"</a></em>, SIAM, 2009</li>
<li>Naumann, U., <em><a href="http://books.google.co.uk/books/about/The_Art_of_Differentiating_Computer_Prog.html?id=OgQuUR4nLu0C&amp;redir_esc=y">The Art of Differentiating Computer Programs: An Introduction to Algorithmic Differentiation</a></em>, SIAM, 2009</li>
<li>Neumaier, A., <a href="http://dx.doi.org/10.1023/A:1023061927787">Taylor forms&ndash;Use and limits</a>, <em>Reliable Computing</em>, <b>9</b>(1):43-79, 2002</li>
<li>Schichl, H., A. Neumaier, <a href="http://dx.doi.org/10.1007/s10898-005-0937-x">Interval Analysis on Directed Acyclic Graphs for Global Optimization</a>, <em>Journal of Global Optimization</em>, <b>33</b>:541–562, 2005 </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 1 2017 01:17:05 for MC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
