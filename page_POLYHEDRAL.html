<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MC++: Polyhedral Arithmetic for Factorable Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=HTML-CSS/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MC++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_POLYHEDRAL.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Polyhedral Arithmetic for Factorable Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Beno&icirc;t Chachuat</dd></dl>
<p>Consider the image set \(\Gamma:\{{\bf g}({\bf x}) \,\mid\, {\bf x}^{\rm L}\leq{\bf x}\leq{\bf x}^{\rm U}\} \subseteq \mathbb R^m\), where \(g_j:\mathbb{R}^n\to\mathbb R, j=1,\ldots,m\), are factorable, potentially nonconvex functions. The classes <a class="el" href="classmc_1_1PolImg.html" title="C++ class for polytopic image evaluation. ">mc::PolImg</a> and <a class="el" href="classmc_1_1PolVar.html" title="C++ class for defining polytopic image variables. ">mc::PolVar</a> implement an arithmetic for the construction of a polyedral enclosure \(\Gamma\) of the set \(\overline{\Gamma}\) in the form: </p><p class="formulaDsp">
\begin{align*} \overline{\Gamma} := \left\{ {\bf G} {\bf v}\; \middle|\; \begin{array}{l} {\bf A} {\bf v} \;=\; {\bf 0}\\ {\bf B} {\bf v} \;\leq\; {\bf 0}\\ {\bf v}^{\rm L}\leq{\bf v}\leq{\bf v}^{\rm U} \end{array} \right\} \supseteq \Gamma\, , \end{align*}
</p>
<p> where the variable vector \(v\) contains the original variable vector \(x\)</p>
<p>These classes build upon the DAG classes <a class="el" href="classmc_1_1FFGraph.html" title="C++ class representing the DAG of factorable functions. ">mc::FFGraph</a> and <a class="el" href="classmc_1_1FFVar.html" title="Class defining variables in a factorable function. ">mc::FFVar</a>. Both are templated in the interval type used to bound the nonlinearity of the function, By default, <a class="el" href="classmc_1_1PolImg.html" title="C++ class for polytopic image evaluation. ">mc::PolImg</a> and <a class="el" href="classmc_1_1PolVar.html" title="C++ class for defining polytopic image variables. ">mc::PolVar</a> can be used with the non-verified interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> of MC++. For reliability, however, it is recommended to use verified interval arithmetic such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> (header file <code><a class="el" href="mcprofil_8hpp_source.html">mcprofil.hpp</a></code>) or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a> (header file <code><a class="el" href="mcfilib_8hpp_source.html">mcfilib.hpp</a></code>). Note that the implementation in <a class="el" href="classmc_1_1PolImg.html" title="C++ class for polytopic image evaluation. ">mc::PolImg</a> and <a class="el" href="classmc_1_1PolVar.html" title="C++ class for defining polytopic image variables. ">mc::PolVar</a> is not verified in the sense that rounding errors are not accounted for in the polyhedral cuts.</p>
<h1><a class="anchor" id="sec_POLIMG_THEOR"></a>
What is the theory behind polyhedral relaxations?</h1>
<p>The basic procedure follows three steps: (i) decompose the factorable functions \(g_j\) into atom operations, both unary and binary operations, by introducing auxiliary variables and extra constraints (lifting); (ii) generate convex enclosures for the nonlinear operations, including products, divisions and outer-compositions with nonlinear univariates such as exp, log, sin, cos, <em>etc</em>; and (iii) outer-approximate the nonlinear parts of the convex enclosures using supporting hyperplanes at finitely many points. Each step is detailed further below.</p>
<ul>
<li><b>Step 1. Decomposition/Lifting</b> <p class="formulaDsp">
\begin{align*} \Gamma:\{{\bf g}({\bf x}) \,\mid\, {\bf x}^{\rm L}\leq{\bf x}\leq {\bf x}^{\rm U}\} &amp; \xrightarrow{\displaystyle\text{decomp.}} &amp;&amp; \overline{\Gamma} := \left\{ {\bf G} {\bf v}\; \middle|\; \begin{array}{l} {\bf A} {\bf v} \;=\; {\bf 0}\\ v_k = v_iv_j,\ \forall (i,j,k)\in\mathcal{B}\\ v_k = \frac{v_i}{v_j},\ \forall (i,j,k)\in\mathcal{F}\\ v_k = \varphi(v_i),\ \forall (i,k)\in\mathcal{U}\\ {\bf v}^{\rm L}\leq{\bf v}\leq {\bf v}^{\rm U} \end{array} \right\} \end{align*}
</p>
 The advantage of this decomposition, which may be applied to any factorable function, is that it accounts for common subexpressions, thus enables tighter relaxations. Its main drawback, on the other hand, is that it may introduce a large number of auxiliary variables and constraints.</li>
<li><b>Step 2. Relaxation</b><ul>
<li>The bilinear terms \(v_k = v_iv_j\), \(v_i^{\rm L}\leq v_i\leq v_i^{\rm U}\), \(v_j^{\rm L}\leq v_j\leq v_j^{\rm U}\), can be replaced by their polyhedral envelopes as <p class="formulaDsp">
\begin{align*} v_k=v_iv_j \quad \xrightarrow{\displaystyle\text{relax.}}\quad \left\{\begin{array}{l} v_k \geq v_i^{\rm L}v_j+v_j^{\rm L}v_i-v_i^{\rm L}v_j^{\rm L}\\ v_k \geq v_i^{\rm U}v_j+v_j^{\rm U}v_i-v_i^{\rm U}v_j^{\rm U}\\ v_k \leq v_i^{\rm U}v_j+v_j^{\rm L}v_i-v_i^{\rm U}v_j^{\rm L}\\ v_k \leq v_i^{\rm L}v_j+v_j^{\rm U}v_i-v_i^{\rm L}v_j^{\rm U} \end{array}\right. \end{align*}
</p>
</li>
<li>The fractional terms \(v_k = \frac{v_i}{v_j}\), \(v_i^{\rm L}\leq v_i\leq v_i^{\rm U}\), \(v_j^{\rm L}\leq v_j\leq v_j^{\rm U}\), \(0\notin[v_j^{\rm L},v_j^{\rm U}]\), can be rewritten as bilinear terms \(v_i = v_jv_k\) and relaxed as indicated above, with the following bounds for the variables \(v_k\): <p class="formulaDsp">
\begin{align*} \min\left\{\frac{v_j^{\rm L}}{v_k^{\rm L}}, \frac{v_j^{\rm L}}{v_k^{\rm U}}, \frac{v_j^{\rm U}}{v_k^{\rm L}}, \frac{v_j^{\rm U}}{v_k^{\rm U}}\right\} =: v_k^{\rm L} \leq v_k \leq v_k^{\rm U} := \max\left\{\frac{v_j^{\rm L}}{v_k^{\rm L}}, \frac{v_j^{\rm L}}{v_k^{\rm U}}, \frac{v_j^{\rm U}}{v_k^{\rm L}}, \frac{v_j^{\rm U}}{v_k^{\rm U}}\right\} \end{align*}
</p>
 Note that, although straightforward, this approach of dealing with fractional terms does not generally yield the convex/concave envelopes (which turn out to be quite complicated nonlinear expressions &ndash; see <a class="el" href="page_POLYHEDRAL.html#sec_POLIMG_REFS">References</a>). <br />
</li>
<li>The univariate terms \(v_k = \varphi(v_i)\), \(v_i^{\rm L}\leq v_i\leq v_i^{\rm U}\), are relaxed differently depending on whether the function \(\varphi\) is convex, concave, convexo-concave, etc., on \([v_i^{\rm L},v_i^{\rm U}]\). <p class="formulaDsp">
\begin{align*} \text{convex case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \varphi(v_i)\\ v_k \leq \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_i^{\rm L})}{v_i^{\rm U}-v_i^{\rm L}}(v_i-v_i^{\rm L}) \end{array}\right.\\ \text{concave case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_i^{\rm L})}{v_i^{\rm U}-v_i^{\rm L}}(v_i-v_i^{\rm L})\\ v_k \leq \varphi(v_i) \end{array}\right.\\ \text{convexo-concave case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \left\{\begin{array}{ll} \varphi(v_i), &amp; \text{if $v_i\leq v_{\rm m}^{\rm cv}$}\\ \varphi(v_i^{\rm U}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_{\rm m}^{\rm cv})}{v_i^{\rm U}-v_{\rm m}^{\rm cv}}(v_i-v_i^{\rm U}), &amp; \text{otherwise} \end{array}\right.\\ v_k \leq \left\{\begin{array}{ll} \varphi(v_i), &amp; \text{if $v_i\geq v_{\rm m}^{\rm cc}$}\\ \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm L})-\varphi(v_{\rm m}^{\rm cc})}{v_i^{\rm L}-v_{\rm m}^{\rm cc}}(v_i-v_i^{\rm L}), &amp; \text{otherwise} \end{array}\right. \end{array}\right.\\ &amp; \quad \text{with:}\ v_{\rm m}^{\rm cv},v_{\rm m}^{\rm cc}\in[v_i^{\rm L},v_i^{\rm U}]:\ \varphi&#39;(v_{\rm m}^{\rm cv}) = \textstyle\frac{\varphi(v_i^{\rm U})-\varphi(v_{\rm m}^{\rm cv})}{v_i^{\rm U}-v_{\rm m}^{\rm cv}} \text{ and } \varphi&#39;(v_{\rm m}^{\rm cc}) = \textstyle\frac{\varphi(v_i^{\rm L})-\varphi(v_{\rm m}^{\rm cc})}{v_i^{\rm L}-v_{\rm m}^{\rm cc}} \end{align*}
</p>
 <div class="image">
<img src="exm_uni.png" alt="exm_uni.png"/>
</div>
 <br />
</li>
</ul>
</li>
<li><b>Step 3. Polyhedral Outer-Approximation</b><br />
Every convex, nonlinear univariate constraint generated in Step 2 is outer-approximated by constructing supporting cuts at a number of well-chosen points. Although the resulting polyhedral relaxations are inherently weaker than the nonlinear relaxations, LP solvers are currently more robust and faster than NLP solvers.<br />
An iterative scheme (a.k.a. sandwich algorithm) can be applied that adds linearization points in such a way that the maximum distance \(\delta^{\rm max}\) between the nonlinear constraint and its polyhedral approximation decreases as the inverse of the square of the number \(n\) of linearization points; that is, \(\delta^{\rm max}\propto \frac{1}{n^2}\). This algorithm proceeds as follows:<ol type="1">
<li>Construct cuts at both interval end-points \(v_i^{\rm L}\) and \(v_i^{\rm U}\)</li>
<li><b>REPEAT</b><ul>
<li>Identify an interval \([v_i^\ell,v_i^{\ell+1}]\) with maximum outer-approximation error \(\delta_{\rm max}\)</li>
<li>Subdivide \([v_i^\ell,v_i^{\ell+1}]\) at a suitably chosen point \(v_i^{\rm new}\)</li>
</ul>
<b>UNTIL</b> \(\delta_{\rm max} &lt; \varepsilon^{\rm tol}\)</li>
</ol>
In particular, several strategies have been proposed for selecting a new linearization point \(v_i^{\rm new}\). The <em>interval bisection rule</em> and the <em>maximum error rule</em> are depicted below.</li>
</ul>
<div class="image">
<img src="OAcvx_strategy.png" alt="OAcvx_strategy.png"/>
</div>
<h1><a class="anchor" id="sec_POLIMG_COMP"></a>
How to generate a polyhedral relaxation of a factorable function?</h1>
<p>For illustration, suppose that we want to compute a polyhedral enclosure for the image set of function: </p><p class="formulaDsp">
\[ {\bf g}(x) := \left(\begin{array}{c} \log(x_1)+x^2_2 \\ \sin(x_1)-\cos(x_2) \\ \end{array} \right) \qquad \text{with} \qquad x \in [1,5]\times [2,6]. \]
</p>
<p>For simplicity, the underlying interval bounds are propagated using the default interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a>, the required header files are:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;interval.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html">mc::Interval</a> I;</div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;polimage.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1PolImg.html">mc::PolImg&lt;I&gt;</a> PI;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1PolVar.html">mc::PolVar&lt;I&gt;</a> PV;</div></div><!-- fragment --><p>First, the DAG of the vector function \({\bf g}\) is defined: </p><div class="fragment"><div class="line"><a class="code" href="classmc_1_1FFGraph.html">mc::FFGraph</a> DAG;</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> X[2]; X[0].<a class="code" href="group__FFunc.html#ga01b248e64b08d4a73bcb883aa13b2d77">set</a>( &amp;DAG ); X[1].<a class="code" href="group__FFunc.html#ga01b248e64b08d4a73bcb883aa13b2d77">set</a>( &amp;DAG );</div><div class="line"><a class="code" href="classmc_1_1FFVar.html">mc::FFVar</a> F[2]; F[0] = log(X[0])+pow(X[1],2); F[1] = sin(X[0])-cos(X[1]); </div><div class="line">std::cout &lt;&lt; DAG;</div></div><!-- fragment --><p>The following output is displayed, including the auxiliary variables created during the DAG decomposition of the factorable functions: </p><pre class="fragment">  DAG VARIABLES:
    X0    =&gt; { Z1 Z4 }
    X1    =&gt; { Z0 Z3 }

  DAG INTERMEDIATES:
    Z0    &lt;=  SQR( X1 )       =&gt; { Z2 }
    Z1    &lt;=  LOG( X0 )       =&gt; { Z2 }
    Z2    &lt;=  Z0 + Z1         =&gt; { }
    Z3    &lt;=  COS( X1 )       =&gt; { Z5 }
    Z4    &lt;=  SIN( X0 )       =&gt; { Z5 }
    Z5    &lt;=  Z4 - Z3         =&gt; { }
</pre><p>Next, the polyhedral relaxation environment is created and the main variables are initialized: </p><div class="fragment"><div class="line"><a class="code" href="classmc_1_1PolImg.html">mc::PolImg&lt;I&gt;</a> Env;</div><div class="line">I IX[2] = { I(1,5), I(2,6) };</div><div class="line"><a class="code" href="classmc_1_1PolVar.html">mc::PolVar&lt;I&gt;</a> PX[2]; PX[0].<a class="code" href="classmc_1_1PolVar.html#a709f7b919c3b211c8cf5a193faac5235">set</a>( &amp;Env, X[0], IX[0] ); PX[1].<a class="code" href="classmc_1_1PolVar.html#a709f7b919c3b211c8cf5a193faac5235">set</a>( &amp;Env, X[1], IX[1] );</div></div><!-- fragment --><p>Then, the polyhedral relaxation of the image set is initialized by propagating bounds for the lifted variables through the DAG: </p><div class="fragment"><div class="line"><a class="code" href="classmc_1_1PolVar.html">mc::PolVar&lt;I&gt;</a> PF[2]; DAG.eval( 2, F, PF, 2, X, PX );</div><div class="line">std::cout &lt;&lt; Env;</div></div><!-- fragment --><p>This produces the following output, where no cuts have been generated to define the polyhedral enclosure yet: </p><pre class="fragment">VARIABLES:
  X0   in [  1.00000e+00 :  5.00000e+00 ]  (DAG: X0)
  X1   in [  2.00000e+00 :  6.00000e+00 ]  (DAG: X1)
  X2   in [  4.00000e+00 :  3.60000e+01 ]  (DAG: Z0)
  X3   in [  0.00000e+00 :  1.60944e+00 ]  (DAG: Z1)
  X4   in [  4.00000e+00 :  3.76094e+01 ]  (DAG: Z2)
  X6   in [ -1.00000e+00 :  9.60170e-01 ]  (DAG: Z3)
  X5   in [ -1.00000e+00 :  1.00000e+00 ]  (DAG: Z4)
  X7   in [ -1.96017e+00 :  2.00000e+00 ]  (DAG: Z5)

NO AUXILIARY

NO BILINEAR OR FRACTIONAL TERM

NO CUT
</pre><p>Finally, polyhedral cuts are generated and displayed as follows: </p><div class="fragment"><div class="line">Env.generate_cuts( 2, PF );</div><div class="line">std::cout &lt;&lt; Env;</div></div><!-- fragment --><pre class="fragment">VARIABLES:
  X0   in [  1.00000e+00 :  5.00000e+00 ]  (DAG: X0)
  X1   in [  2.00000e+00 :  6.00000e+00 ]  (DAG: X1)
  X2   in [  4.00000e+00 :  3.60000e+01 ]  (DAG: Z0)
  X3   in [  0.00000e+00 :  1.60944e+00 ]  (DAG: Z1)
  X4   in [  4.00000e+00 :  3.76094e+01 ]  (DAG: Z2)
  X6   in [ -1.00000e+00 :  9.60170e-01 ]  (DAG: Z3)
  X5   in [ -1.00000e+00 :  1.00000e+00 ]  (DAG: Z4)
  X7   in [ -1.96017e+00 :  2.00000e+00 ]  (DAG: Z5)

NO AUXILIARY

NO BILINEAR OR FRACTIONAL TERM

CUTS:
  + 1.00000e+00X2 + 1.00000e+00X3 - 1.00000e+00X4 = -0.00000e+00
  + 1.00000e+00X5 - 1.00000e+00X6 - 1.00000e+00X7 = -0.00000e+00
  + 4.00000e+00X3 - 1.60944e+00X0 &gt;= -1.60944e+00
  + 1.00000e+00X0 - 1.00000e+00X3 &gt;= 1.00000e+00
  + 1.00000e+00X0 - 5.00000e+00X3 &gt;= -3.04719e+00
  + 1.00000e+00X0 - 2.75054e+00X3 &gt;= -3.24492e-02
  + 1.00000e+00X0 - 1.80361e+00X3 &gt;= 7.39860e-01
  + 1.00000e+00X0 - 3.81983e+00X3 &gt;= -1.29953e+00
  + 4.00000e+00X2 - 3.20000e+01X1 &lt;= -4.80000e+01
  + 1.00000e+00X5 - 5.40302e-01X0 &lt;= 3.01169e-01
  + 1.00000e+00X5 + 0.00000e+00X0 &lt;= 1.00000e+00
  + 1.00000e+00X5 - 2.73845e-01X0 &lt;= 6.07581e-01
  + 1.00000e+00X5 - 4.08535e-01X0 &lt;= 4.42948e-01
  + 1.00000e+00X5 - 1.37362e-01X0 &lt;= 7.93681e-01
  + 1.00000e+00X5 + 0.00000e+00X0 &lt;= 1.00000e+00
  + 1.00000e+00X5 + 6.31638e-01X0 &lt;= 2.19927e+00
  + 1.00000e+00X5 + 3.22022e-01X0 &lt;= 1.55814e+00
  + 1.00000e+00X5 + 4.79346e-01X0 &lt;= 1.87021e+00
  + 1.00000e+00X5 + 1.61734e-01X0 &lt;= 1.26716e+00
  + 1.00000e+00X6 - 3.44637e-01X1 &lt;= -1.10542e+00
  + 1.00000e+00X6 - 2.79415e-01X1 &lt;= -7.16323e-01
  + 1.00000e+00X2 - 4.00000e+00X1 &gt;= -4.00000e+00
  + 1.00000e+00X2 - 1.20000e+01X1 &gt;= -3.60000e+01
  + 1.00000e+00X2 - 8.00000e+00X1 &gt;= -1.60000e+01
  + 1.00000e+00X2 - 6.00000e+00X1 &gt;= -9.00000e+00
  + 1.00000e+00X2 - 1.00000e+01X1 &gt;= -2.50000e+01
  + 1.00000e+00X5 + 5.35701e-01X0 &gt;= 1.37717e+00
  + 1.00000e+00X5 + 0.00000e+00X0 &gt;= -1.00000e+00
  + 1.00000e+00X5 + 2.71443e-01X0 &gt;= 2.42071e-01
  + 1.00000e+00X5 + 4.04992e-01X0 &gt;= 8.25290e-01
  + 1.00000e+00X5 + 1.36150e-01X0 &gt;= -3.67693e-01
  + 1.00000e+00X5 + 0.00000e+00X0 &gt;= -1.00000e+00
  + 1.00000e+00X5 - 2.83662e-01X0 &gt;= -2.37724e+00
  + 1.00000e+00X5 - 1.42321e-01X0 &gt;= -1.68082e+00
  + 1.00000e+00X5 - 2.13178e-01X0 &gt;= -2.02739e+00
  + 1.00000e+00X5 - 7.12210e-02X0 &gt;= -1.33816e+00
  + 1.00000e+00X6 + 9.09297e-01X1 &gt;= 1.40245e+00
  + 1.00000e+00X6 + 0.00000e+00X1 &gt;= -1.00000e+00
  + 1.00000e+00X6 + 4.78987e-01X1 &gt;= 3.87705e-01
  + 1.00000e+00X6 + 7.05713e-01X1 &gt;= 9.55690e-01
  + 1.00000e+00X6 + 2.41998e-01X1 &gt;= -2.69168e-01
  + 1.00000e+00X6 + 0.00000e+00X1 &gt;= -1.00000e+00
  + 1.00000e+00X6 - 8.07940e-01X1 &gt;= -3.88747e+00
  + 1.00000e+00X6 - 4.18937e-01X1 &gt;= -2.40524e+00
  + 1.00000e+00X6 - 6.19996e-01X1 &gt;= -3.14699e+00
  + 1.00000e+00X6 - 2.11107e-01X1 &gt;= -1.68558e+00
</pre><p>By default, the cuts in the polyhedral relaxation of a convex univariate terms are generated according to the <em>maximum error rule</em> (see above), and a maximum of 5 cuts are generated for each nonlinear constraint. The cut generation is also controlled by the absolute and relative tolerances on the maximum outer-approximation error, which are both set to \(10^{-3}\) by default. All these default values can be altered as explained below in the section <a class="el" href="page_POLYHEDRAL.html#sec_POLIMG_OPT">What are the options in computing a polyhedral relaxation?</a> below.</p>
<p>All the cuts can be retreived by using the function <a class="el" href="classmc_1_1PolImg.html#a595566c44b58ae872d5eb2762f9ac1a5" title="Retreive reference to set of cuts in polytopic image. ">mc::PolImg::Cuts</a>, which returns a set of cuts as defined in the class mc::PolCuts.</p>
<h1><a class="anchor" id="sec_POLIMG_OPT"></a>
What are the options in computing a polyhedral relaxation?</h1>
<p>All the options are defined in the structure <a class="el" href="structmc_1_1PolImg_1_1Options.html" title="PolImg options class. ">mc::PolImg::Options</a>, and the default values can be altered via the public static member <a class="el" href="classmc_1_1PolImg.html#ac28c262e94414d4602a0d314b9b590ba" title="PolImg options handle. ">mc::PolImg::options</a>; for example:</p>
<div class="fragment"><div class="line">Env.options.AGGREG_LIN = <span class="keyword">false</span>;</div><div class="line">Env.options.SANDWICH_MAXCUT = 7;</div></div><!-- fragment --><h1><a class="anchor" id="sec_POLIMG_ERR"></a>
What errors may be encoutered in computing a polyhedral relaxation?</h1>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, an instance of the class <a class="el" href="classmc_1_1PolImg_1_1Exceptions.html" title="PolImg exceptions. ">mc::PolImg::Exceptions</a> is thrown, which contains the type of error. Additional exceptions may be sent by the template argument class in propagating the bounds through the DAG, as well as by the DAG class itself. It is the responsibility of a user to test whether an exception was thrown, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, execution will abort.</p>
<h1><a class="anchor" id="sec_POLIMG_REFS"></a>
References</h1>
<ul>
<li>Tawarmalani, M., and N.V. Sahinidis, <a href="http://dx.doi.org/10.1007/s10107-003-0467-6">Global optimization of mixed-integer nonlinear programs: A theoretical and computational study</a>, <em>Mathematical Programming</em>, <b>99</b>(3):563-591, 2004.</li>
<li>Smith, E.M.B, and C.C. Pantelides, <a href="http://dx.doi.org/10.1016/S0098-1354(98)00286-5">A symbolic reformulation/spatial branch-and-bound algorithm for the global optimisation of nonconvex MINLPs</a>, <em>Computers &amp; Chemical Engineering</em>, <b>23</b>(4-5):457-478, 1999.</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 1 2017 01:17:05 for MC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
