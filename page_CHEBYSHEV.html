<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MC++: Chebyshev Model Arithmetic for Factorable Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=HTML-CSS/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MC++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_CHEBYSHEV.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Chebyshev Model Arithmetic for Factorable Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jai Rajyaguru, Mario E. Villanueva, Beno&icirc;t Chachuat</dd></dl>
<p>A \(q\)th-order Chebyshev model of a Lipschitz-continuous function \(f:\mathbb{R}^n\to\mathbb{R}\) on the domain \(D\), consists of a \(q^{\rm th}\)-order multivariate polynomial \(\mathcal P\) in Chebyshev basis , plus a remainder term \(\mathcal R\), so that </p><p class="formulaDsp">
\begin{align*} f({x}) \in \mathcal P({x}) \oplus \mathcal R, \quad \forall {x}\in D. \end{align*}
</p>
<p> The polynomial part \(\mathcal P\) is propagated symbolically and accounts for functional dependencies. The remainder term \(\mathcal R\), on the other hand, is traditionally computed using interval analysis [Brisebarre &amp; Joldes, 2010]; see figure below. More generally, convex/concave bounds or an ellipsoidal enclosure can be computed for the remainder term of vector-valued functions too. In particular, it can be established that the remainder term has convergence order (no less than) \(q+1\) with respect to the diameter of the domain set \(D\) under mild conditions [Bompadre <em>et al.</em>, 2012].</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="Chebyshev_model.png" alt="Chebyshev_model.png"/>
</div>
  </td></tr>
</table>
</center><p>The classes <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> provide an implementation of Chebyshev model arithmetic. We note that <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> / <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> is <b>not a verified implementation</b> in the sense that rounding errors are not accounted for in propagating the coefficients in the multivariate polynomial part, which are treated as floating-point numbers.</p>
<p>The implementation of <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> relies on the operator/function overloading mechanism of C++. This makes the computation of Chebyshev models both simple and intuitive, similar to computing function values in real arithmetics or function bounds in interval arithmetic (see <a class="el" href="page_INTERVAL.html">Non-Verified Interval Arithmetic for Factorable Functions</a>). Moreover, <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> can be used as the template parameter of other available types in MC++; for instance, <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> can be used in order to propagate the underlying interval bounds in <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a>. Likewise, <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> can be used as the template parameter of the types fadbad::F, fadbad::B and fadbad::T of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> for computing Chebyshev models of either the partial derivatives or the Chebyshev coefficients of a factorable function (see sec_CHEBYSHEV_fadbad).</p>
<p><a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> themselves are templated in the type used to propagate bounds on the remainder term. By default, <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> can be used with the non-verified interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> of MC++. For reliability, however, it is strongly recommended to use verified interval arithmetic such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> (header file <code><a class="el" href="mcprofil_8hpp_source.html">mcprofil.hpp</a></code>) or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a> (header file <code><a class="el" href="mcfilib_8hpp_source.html">mcfilib.hpp</a></code>). As already noted, convex/concave bounds on the remainder term can also be propagated by using the type <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a> of MC++, thereby enabling McCormick-Chebyshev models.</p>
<p>As well as propagating Chebyshev models for factorable functions, <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> provide support for computing bounds on the Chebyshev model range (multivariate polynomial part). We note that computing exact bounds for multivariate polynomials is a hard problem in general. Instead, a number of computationally tractable, yet typically conservative, bounding approaches are implemented in <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a>, which include:</p><ul>
<li>Bounding every monomial term independently and adding these bounds;</li>
<li>Bounding the first- and diagonal second-order terms exactly and adding bounds for the second-order off-diagonal and higher-order terms computed independently [Lin &amp; Stadtherr, 2007];</li>
<li>Bounding the terms up to order 2 based on an eigenvalue decomposition of the corresponding Hessian matrix and adding bounds for the higher-order terms computed independently;</li>
<li>Expressing the multivariate polynomial in Bernstein basis, thereby providing bounds as the minimum/maximum among all Bernstein coefficients [Lin &amp; Rokne, 1995; 1996].</li>
</ul>
<p>Examples of Chebyshev models (blue lines) constructed with <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> are shown on the figure below for the factorable function \(f(x)=x \exp(-x^2)\) (red line) for \(x\in [-0.5,1]\). Also shown on these plots are the interval bounds computed from the Chebyshev models.</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="CM-1D.png" alt="CM-1D.png"/>
</div>
  </td></tr>
</table>
</center><h1><a class="anchor" id="sec_CHEBYSHEV_I"></a>
How do I compute a Chebyshev model with interval remainder bound of a factorable function?</h1>
<p>Suppose we want to compute a 4th-order Chebyshev model for the real-valued function \(f(x,y)=x\exp(x+y^2)-y^2\) with \((x,y)\in [1,2]\times[0,1]\). For simplicity, bounds on the remainder terms are computed using the default interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;interval.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cmodel.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html">mc::Interval</a> I;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1CModel.html">mc::CModel&lt;I&gt;</a> CM;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1CVar.html">mc::CVar&lt;I&gt;</a> CV;</div></div><!-- fragment --><p>First, the number of independent variables in the factorable function ( \(x\) and \(y\) here) as well as the order of the Chebyshev model (4th order here) are specified by defining an <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> object as:</p>
<div class="fragment"><div class="line">CM mod( 2, 4 );</div></div><!-- fragment --><p>Next, the variables \(x\) and \(y\) are defined as follows:</p>
<div class="fragment"><div class="line">CV X( &amp;mod, 0, I(1.,2.) );</div><div class="line">CV Y( &amp;mod, 1, I(0.,1.) );</div></div><!-- fragment --><p>Essentially, the first line means that <code>X</code> is a variable of class <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a>, participating in the Chebyshev model <code>mod</code>, belonging to the interval \([1,2]\), and having index 0 (indexing in C/C++ start at 0 by convention!). The same holds for the Chebyshev variable <code>Y</code>, participating in the model <code>mod</code>, belonging to the interval \([0,1]\), and having index 1.</p>
<p>Having defined the variables, a Chebyshev model of \(f(x,y)=x\exp(x+y^2)-y^2\) on \([1,2]\times[0,1]\) at the mid-point \((\frac{3}{2},\frac{1}{2})\) is simply computed as:</p>
<div class="fragment"><div class="line">CV F = X*exp(X+pow(Y,2))-pow(Y,2);</div></div><!-- fragment --><p>This model can be displayed to the standard output as:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;f Chebyshev model: &quot;</span> &lt;&lt; F &lt;&lt; std::endl;</div></div><!-- fragment --><p>which produces the following output:</p>
<pre class="fragment">f Chebyshev model: 
   a0    =  8.38199e+00     0  0
   a1    =  1.90755e+00     0  1
   a2    =  3.59621e+00     1  0
   a3    =  7.47482e-01     0  2
   a4    =  9.00782e-01     1  1
   a5    =  6.30186e-01     2  0
   a6    =  1.56945e-01     0  3
   a7    =  3.35238e-01     1  2
   a8    =  1.55141e-01     2  1
   a9    =  6.67468e-02     3  0
   a10   =  3.49519e-02     0  4
   a11   =  6.58449e-02     1  3
   a12   =  6.04330e-02     2  2
   a13   =  1.80397e-02     3  1
   a14   =  5.41191e-03     4  0
   R     =  [ -2.09182e+00 :  2.22652e+00 ]
   B     =  [ -1.02564e+01 :  3.93973e+01 ]
</pre><p><code>a0</code>,...,<code>a14</code> refer to the coefficients of the monomial terms in the Chebyshev model, with the corresponding variable orders given in the subsequent columns. The remainder term as well as the Chebyshev model range estimator are reported next.</p>
<p>Other operations involve retreiving the remainder bound, centering the remainder term in a Chebyshev model, or computing the value of its polynomial part at a given point:</p>
<div class="fragment"><div class="line">I B = F.B();</div><div class="line">F.C();</div><div class="line"><span class="keywordtype">double</span> x[2] = { 0.5, 1.5 };</div><div class="line"><span class="keywordtype">double</span> Pval = F.P( x );</div></div><!-- fragment --><p>See the documentations of <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> and <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> for a complete list of member functions.</p>
<h1><a class="anchor" id="sec_CHEBYSHEV_fct"></a>
Which functions are overloaded for Chebyshev model arithmetic?</h1>
<p><a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> overloads the usual functions <code>exp</code>, <code>log</code>, <code>sqr</code>, <code>sqrt</code>, <code>pow</code>, <code>inv</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>. Unlike <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> and <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a>, the functions <code>min</code>, <code>max</code> and <code>fabs</code> are not overloaded in <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> as they are nonsmooth. Moreover, <a class="el" href="classmc_1_1CVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::CVar</a> defines the following functions:</p><ul>
<li><code>inter(x,y,z)</code>, computing a Chebyshev model of the intersection \(x = y\cap z\) of two Chebyshev models and returning true/false if the intersection is nonempty/empty. With Chebyshev models \(\mathcal P_y\oplus\mathcal R_y\) and \(\mathcal P_z\oplus\mathcal R_z\), this intersection is computed as follows: <p class="formulaDsp">
\begin{align*} \mathcal P_{x} =\ &amp; (1-\eta) \mathcal P_y^{\rm C} + \eta \mathcal P_z^{\rm C}\\ \mathcal R_{x} =\ &amp; [\mathcal R_y^{\rm C}\oplus\eta\mathcal{B}(\mathcal P_y^{\rm C}-\mathcal P_z^{\rm C})] \cap [\mathcal R_z^{\rm C}\oplus (1-\eta)\mathcal{B}(\mathcal P_z^{\rm C}-\mathcal P_y^{\rm C})]\,. \end{align*}
</p>
 with \(\mathcal{B}(\cdot)\) the Chebyshev model range bounder, and \(\eta\) a real scalar in \([0,1]\). Choosing \(\eta=1\) amounts to setting the polynomial part \(\mathcal P_{x}\) as \(\mathcal P_y\), whereas \(\eta=0\) sets \(\mathcal P_{x}\) as \(\mathcal P_z\). The parameter \(\eta\) can be defined in <a class="el" href="structmc_1_1CModel_1_1Options.html#ade7873bcbcae5ca62f345f657666f896" title="Scalar in  related to the choice of the polynomial part in the overloaded functions mc::inter and mc:...">mc::CModel::Options::REF_POLY</a>.</li>
<li><code>hull(x,y)</code>, computing a Chebyshev model of the union \(x = y\cup z\) of two Chebyshev models. With Chebyshev models \(\mathcal P_y\oplus\mathcal R_y\) and \(\mathcal P_z\oplus\mathcal R_z\), this union is computed as follows: <p class="formulaDsp">
\begin{align*} \mathcal P_{x} =\ &amp; (1-\eta) \mathcal P_y^{\rm C} + \eta \mathcal P_z^{\rm C}\\ \mathcal R_{x} =\ &amp; {\rm hull}\{\mathcal R_y^{\rm C}\oplus\eta\mathcal{B}(\mathcal P_y^{\rm C}-\mathcal P_z^{\rm C}), \mathcal R_z^{\rm C}\oplus (1-\eta)\mathcal{B}(\mathcal P_z^{\rm C}-\mathcal P_y^{\rm C})\}\,. \end{align*}
</p>
 with \(\mathcal{B}(\cdot)\) and \(\eta\) as previously.</li>
</ul>
<h1><a class="anchor" id="sec_CHEBYSHEV_opt"></a>
How are the options set for the computation of a Chebyshev model?</h1>
<p>The class <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> has a public member called mc::CModel::options that can be used to set/modify the options; e.g.,</p>
<div class="fragment"><div class="line">model.options.BOUNDER_TYPE = CM::Options::EIGEN;</div><div class="line">model.options.SCALE_VARIABLES = <span class="keyword">true</span>;</div></div><!-- fragment --><p>The available options are the following:</p>
<a class="anchor" id=""></a>
<table  border="1">
<caption><em>Options in <a class="el" href="structmc_1_1CModel_1_1Options.html" title="Options of mc::CModel. ">mc::CModel::Options</a>: name, type and description</em></caption>
<tr>
<th><b>Name</b> </th><td><b>Type</b></td><td><b>Default</b> </td><td><b>Description</b> </td></tr>
<tr>
<th><code>BOUNDER_TYPE</code> </th><td><code><a class="el" href="structmc_1_1CModel_1_1Options.html#afb23ad3031e9c4e0ae7f21050d57cbaa" title="Chebyshev model range bounder option. ">mc::CModel::Options::BOUNDER</a></code> </td><td><a class="el" href="structmc_1_1CModel_1_1Options.html#afb23ad3031e9c4e0ae7f21050d57cbaaae0409753d9cbcd6c47b21859f6c217cc" title="Lin &amp; Stadtherr range bounder. ">mc::CModel::Options::LSB</a> </td><td>Chebyshev model range bounder. </td></tr>
<tr>
<th><code>BOUNDER_ORDER</code> </th><td><code>unsigned int</code> </td><td>0 </td><td>Order of Bernstein polynomial for Chebyshev model range bounding, when mc::CModel::options::BOUNDER_TYPE = mc::CModel::options::BERNSTEIN is selected. Only values greater than the actual Chebyshev model order are accounted for; see [Lin &amp; Rokne, 1996]. </td></tr>
<tr>
<th><code>REF_POLY</code> </th><td><code>double</code> </td><td>0. </td><td>Scalar in \([0,1]\) related to the choice of the polynomial part in the overloaded functions mc::inter and mc::hull (see <a class="el" href="page_CHEBYSHEV.html#sec_CHEBYSHEV_fct">Which functions are overloaded for Chebyshev model arithmetic?</a>). A value of 0. amounts to selecting the polynomial part of the left operand, whereas a value of 1. selects the right operand. </td></tr>
<tr>
<th><code>DISPLAY_DIGITS</code> </th><td><code>unsigned int</code> </td><td>5 </td><td>Number of digits in output stream for Chebyshev model coefficients. </td></tr>
</table>
<h1><a class="anchor" id="sec_CM_err"></a>
Errors What errors can I encounter during computation of a Chebyshev model?</h1>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, a class object of type <a class="el" href="classmc_1_1CModel_1_1Exceptions.html" title="Exceptions of mc::CModel. ">mc::CModel::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during the computation of a Chebyshev model, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, the execution will abort.</p>
<p>Possible errors encountered during the computation of a Chebyshev model are:</p>
<a class="anchor" id=""></a>
<table  border="1">
<caption><em>Errors during the Computation of a Chebyshev Model</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Division by zero </td></tr>
<tr>
<th><code>2</code> </th><td>Failed to compute eigenvalue decomposition in range bounder CModel::Options::EIGEN </td></tr>
<tr>
<th><code>3</code> </th><td>Failed to compute the maximum gap between a univariate term and its Bernstein model </td></tr>
<tr>
<th><code>-1</code> </th><td>Number of variable in Chebyshev model must be nonzero </td></tr>
<tr>
<th><code>-2</code> </th><td>Failed to construct Chebyshev variable </td></tr>
<tr>
<th><code>-3</code> </th><td>Chebyshev model bound does not intersect with bound in template parameter arithmetic </td></tr>
<tr>
<th><code>-4</code> </th><td>Operation between Chebyshev variables linked to different Chebyshev models </td></tr>
<tr>
<th><code>-5</code> </th><td>Maximum size of Chebyshev model reached (monomials indexed as unsigned int) </td></tr>
<tr>
<th><code>-33</code> </th><td>Feature not yet implemented in <a class="el" href="classmc_1_1CModel.html" title="C++ class for the computation of Chebyshev models of factorable function - Chebyshev model environmen...">mc::CModel</a> </td></tr>
</table>
<p>Moreover, exceptions may be thrown by the template parameter class itself.</p>
<h1><a class="anchor" id="sec_CM_refs"></a>
References</h1>
<ul>
<li>Brisebarre, N., and M. Joldes, <a href="http://hal.archives-ouvertes.fr/docs/00/48/17/37/PDF/RRLIP2010-13.pdf">Chebyshev Interpolation Polynomial-based Tools for Rigorous Computing</a>, <em>Research Report No RR2010-13</em>, Ecole Normale Suprieure de Lyon, Unit Mixte de Recherche CNRS-INRIA-ENS LYON-UCBL No 5668, 2010</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Jai Rajyaguru, Mario E. Villanueva, Beno&icirc;t Chachuat</dd></dl>
<p>template &lt;typename t&gt;=""&gt; inline void SCModel&lt;T&gt;::_sdisp1D ( const std::vector&lt;std::map&lt;unsigned,double&gt;&gt;&amp;CVmap, const unsigned ndxvar, std::string&amp;CVname, ostream&amp;os ) const A \(q\)th-order Chebyshev model of a Lipschitz-continuous function \(f:\mathbb{R}^n\to\mathbb{R}\) on the domain \(D\), consists of a \(q^{\rm th}\)-order multivariate polynomial \(\mathcal P\) in Chebyshev basis , plus a remainder term \(\mathcal R\), so that </p><p class="formulaDsp">
\begin{align*} f({x}) \in \mathcal P({x}-\hat{x}) \oplus \mathcal R, \quad \forall {x}\in D. \end{align*}
</p>
<p> The polynomial part \(\mathcal P\) is propagated symbolically and accounts for functional dependencies. The remainder term \(\mathcal R\), on the other hand, is traditionally computed using interval analysis [Brisebarre &amp; Joldes, 2010]; see figure below. More generally, convex/concave bounds or an ellipsoidal enclosure can be computed for the remainder term of vector-valued functions too. In particular, it can be established that the remainder term has convergence order (no less than) \(q+1\) with respect to the diameter of the domain set \(D\) under mild conditions [Bompadre <em>et al.</em>, 2012].</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="Chebyshev_model.png" alt="Chebyshev_model.png"/>
</div>
  </td></tr>
</table>
</center><p>The classes <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> provide an implementation of Chebyshev model arithmetic. We note that <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> / <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> is <b>not a verified implementation</b> in the sense that rounding errors are not accounted for in propagating the coefficients in the multivariate polynomial part, which are treated as floating-point numbers.</p>
<p>The implementation of <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> relies on the operator/function overloading mechanism of C++. This makes the computation of Chebyshev models both simple and intuitive, similar to computing function values in real arithmetics or function bounds in interval arithmetic (see <a class="el" href="page_INTERVAL.html">Non-Verified Interval Arithmetic for Factorable Functions</a>). Moreover, <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> can be used as the template parameter of other available types in MC++; for instance, <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> can be used in order to propagate the underlying interval bounds in <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a>. Likewise, <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> can be used as the template parameter of the types fadbad::F, fadbad::B and fadbad::T of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> for computing Chebyshev models of either the partial derivatives or the Chebyshev coefficients of a factorable function (see sec_CHEBYSHEV_fadbad).</p>
<p><a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> themselves are templated in the type used to propagate bounds on the remainder term. By default, <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> can be used with the non-verified interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> of MC++. For reliability, however, it is strongly recommended to use verified interval arithmetic such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> (header file <code><a class="el" href="mcprofil_8hpp_source.html">mcprofil.hpp</a></code>) or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a> (header file <code><a class="el" href="mcfilib_8hpp_source.html">mcfilib.hpp</a></code>). As already noted, convex/concave bounds on the remainder term can also be propagated by using the type <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a> of MC++, thereby enabling McCormick-Chebyshev models.</p>
<p>As well as propagating Chebyshev models for factorable functions, <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> provide support for computing bounds on the Chebyshev model range (multivariate polynomial part). We note that computing exact bounds for multivariate polynomials is a hard problem in general. Instead, a number of computationally tractable, yet typically conservative, bounding approaches are implemented in <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a>, which include:</p><ul>
<li>Bounding every monomial term independently and adding these bounds;</li>
<li>Bounding the first- and diagonal second-order terms exactly and adding bounds for the second-order off-diagonal and higher-order terms computed independently [Lin &amp; Stadtherr, 2007];</li>
<li>Bounding the terms up to order 2 based on an eigenvalue decomposition of the corresponding Hessian matrix and adding bounds for the higher-order terms computed independently;</li>
<li>Expressing the multivariate polynomial in Bernstein basis, thereby providing bounds as the minimum/maximum among all Bernstein coefficients [Lin &amp; Rokne, 1995; 1996].</li>
</ul>
<p>Examples of Chebyshev models (blue lines) constructed with <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> are shown on the figure below for the factorable function \(f(x)=x \exp(-x^2)\) (red line) for \(x\in [-0.5,1]\). Also shown on these plots are the interval bounds computed from the Chebyshev models.</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="CM-1D.png" alt="CM-1D.png"/>
</div>
  </td></tr>
</table>
</center><h1><a class="anchor" id="sec_CHEBYSHEV_I"></a>
How do I compute a Chebyshev model with interval remainder bound of a factorable function?</h1>
<p>Suppose we want to compute a 4th-order Chebyshev model for the real-valued function \(f(x,y)=x\exp(x+y^2)-y^2\) with \((x,y)\in [1,2]\times[0,1]\). For simplicity, bounds on the remainder terms are computed using the default interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;interval.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cmodel.hpp&quot;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html">mc::Interval</a> I;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1SCModel.html">mc::SCModel&lt;I&gt;</a> CM;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classmc_1_1SCVar.html">mc::SCVar&lt;I&gt;</a> CV;</div></div><!-- fragment --><p>First, the number of independent variables in the factorable function ( \(x\) and \(y\) here) as well as the order of the Chebyshev model (4th order here) are specified by defining an <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> object as:</p>
<div class="fragment"><div class="line">CM mod( 2, 4 );</div></div><!-- fragment --><p>Next, the variables \(x\) and \(y\) are defined as follows:</p>
<div class="fragment"><div class="line">CV X( &amp;mod, 0, I(1.,2.) );</div><div class="line">CV Y( &amp;mod, 1, I(0.,1.) );</div></div><!-- fragment --><p>Essentially, the first line means that <code>X</code> is a variable of class <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a>, participating in the Chebyshev model <code>mod</code>, belonging to the interval \([1,2]\), and having index 0 (indexing in C/C++ start at 0 by convention!). The same holds for the Chebyshev variable <code>Y</code>, participating in the model <code>mod</code>, belonging to the interval \([0,1]\), and having index 1.</p>
<p>Having defined the variables, a Chebyshev model of \(f(x,y)=x\exp(x+y^2)-y^2\) on \([1,2]\times[0,1]\) at the mid-point \((\frac{3}{2},\frac{1}{2})\) is simply computed as:</p>
<div class="fragment"><div class="line">CV F = X*exp(X+pow(Y,2))-pow(Y,2);</div></div><!-- fragment --><p>This model can be displayed to the standard output as:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;f Chebyshev model: &quot;</span> &lt;&lt; F &lt;&lt; std::endl;</div></div><!-- fragment --><p>which produces the following output:</p>
<pre class="fragment">f Chebyshev model: 
   a0    =  8.38199e+00     0  0
   a1    =  1.90755e+00     0  1
   a2    =  3.59621e+00     1  0
   a3    =  7.47482e-01     0  2
   a4    =  9.00782e-01     1  1
   a5    =  6.30186e-01     2  0
   a6    =  1.56945e-01     0  3
   a7    =  3.35238e-01     1  2
   a8    =  1.55141e-01     2  1
   a9    =  6.67468e-02     3  0
   a10   =  3.49519e-02     0  4
   a11   =  6.58449e-02     1  3
   a12   =  6.04330e-02     2  2
   a13   =  1.80397e-02     3  1
   a14   =  5.41191e-03     4  0
   R     =  [ -2.09182e+00 :  2.22652e+00 ]
   B     =  [ -1.02564e+01 :  3.93973e+01 ]
</pre><p><code>a0</code>,...,<code>a14</code> refer to the coefficients of the monomial terms in the Chebyshev model, with the corresponding variable orders given in the subsequent columns. The remainder term as well as the Chebyshev model range estimator are reported next.</p>
<p>Other operations involve retreiving the remainder bound, centering the remainder term in a Chebyshev model, or computing the value of its polynomial part at a given point:</p>
<div class="fragment"><div class="line">I B = F.B();</div><div class="line">F.C();</div><div class="line"><span class="keywordtype">double</span> x[2] = { 0.5, 1.5 };</div><div class="line"><span class="keywordtype">double</span> Pval = F.P( x );</div></div><!-- fragment --><p>See the documentations of <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> and <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> for a complete list of member functions.</p>
<h1><a class="anchor" id="sec_CHEBYSHEV_fct"></a>
Which functions are overloaded for Chebyshev model arithmetic?</h1>
<p><a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> overloads the usual functions <code>exp</code>, <code>log</code>, <code>sqr</code>, <code>sqrt</code>, <code>pow</code>, <code>inv</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>. Unlike <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function. ">mc::Interval</a> and <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function. ">mc::McCormick</a>, the functions <code>min</code>, <code>max</code> and <code>fabs</code> are not overloaded in <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> as they are nonsmooth. Moreover, <a class="el" href="classmc_1_1SCVar.html" title="C++ class for Chebyshev model computation of factorable function - Chebyshev model propagation...">mc::SCVar</a> defines the following functions:</p><ul>
<li><code>inter(x,y,z)</code>, computing a Chebyshev model of the intersection \(x = y\cap z\) of two Chebyshev models and returning true/false if the intersection is nonempty/empty. With Chebyshev models \(\mathcal P_y\oplus\mathcal R_y\) and \(\mathcal P_z\oplus\mathcal R_z\), this intersection is computed as follows: <p class="formulaDsp">
\begin{align*} \mathcal P_{x} =\ &amp; (1-\eta) \mathcal P_y^{\rm C} + \eta \mathcal P_z^{\rm C}\\ \mathcal R_{x} =\ &amp; [\mathcal R_y^{\rm C}\oplus\eta\mathcal{B}(\mathcal P_y^{\rm C}-\mathcal P_z^{\rm C})] \cap [\mathcal R_z^{\rm C}\oplus (1-\eta)\mathcal{B}(\mathcal P_z^{\rm C}-\mathcal P_y^{\rm C})]\,. \end{align*}
</p>
 with \(\mathcal{B}(\cdot)\) the Chebyshev model range bounder, and \(\eta\) a real scalar in \([0,1]\). Choosing \(\eta=1\) amounts to setting the polynomial part \(\mathcal P_{x}\) as \(\mathcal P_y\), whereas \(\eta=0\) sets \(\mathcal P_{x}\) as \(\mathcal P_z\). The parameter \(\eta\) can be defined in <a class="el" href="structmc_1_1SCModel_1_1Options.html#adcb7532a9e2b216f6dbe848b82cef175" title="Scalar in  related to the choice of the polynomial part in the overloaded functions mc::inter and mc:...">mc::SCModel::Options::REF_POLY</a>.</li>
<li><code>hull(x,y)</code>, computing a Chebyshev model of the union \(x = y\cup z\) of two Chebyshev models. With Chebyshev models \(\mathcal P_y\oplus\mathcal R_y\) and \(\mathcal P_z\oplus\mathcal R_z\), this union is computed as follows: <p class="formulaDsp">
\begin{align*} \mathcal P_{x} =\ &amp; (1-\eta) \mathcal P_y^{\rm C} + \eta \mathcal P_z^{\rm C}\\ \mathcal R_{x} =\ &amp; {\rm hull}\{\mathcal R_y^{\rm C}\oplus\eta\mathcal{B}(\mathcal P_y^{\rm C}-\mathcal P_z^{\rm C}), \mathcal R_z^{\rm C}\oplus (1-\eta)\mathcal{B}(\mathcal P_z^{\rm C}-\mathcal P_y^{\rm C})\}\,. \end{align*}
</p>
 with \(\mathcal{B}(\cdot)\) and \(\eta\) as previously.</li>
</ul>
<h1><a class="anchor" id="sec_CHEBYSHEV_opt"></a>
How are the options set for the computation of a Chebyshev model?</h1>
<p>The class <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> has a public member called mc::SCModel::options that can be used to set/modify the options; e.g.,</p>
<div class="fragment"><div class="line">model.options.BOUNDER_TYPE = CM::Options::EIGEN;</div><div class="line">model.options.SCALE_VARIABLES = <span class="keyword">true</span>;</div></div><!-- fragment --><p>The available options are the following:</p>
<a class="anchor" id=""></a>
<table  border="1">
<caption><em>Options in <a class="el" href="structmc_1_1SCModel_1_1Options.html" title="Options of mc::SCModel. ">mc::SCModel::Options</a>: name, type and description</em></caption>
<tr>
<th><b>Name</b> </th><td><b>Type</b></td><td><b>Default</b> </td><td><b>Description</b> </td></tr>
<tr>
<th><code>BOUNDER_TYPE</code> </th><td><code><a class="el" href="structmc_1_1SCModel_1_1Options.html#afe2f26532fd0fceb6b430b6a40856b50" title="Chebyshev model range bounder option. ">mc::SCModel::Options::BOUNDER</a></code> </td><td><a class="el" href="structmc_1_1SCModel_1_1Options.html#afe2f26532fd0fceb6b430b6a40856b50a0cf49930ef0d6f3542735286bef0bf08" title="Lin &amp; Stadtherr range bounder. ">mc::SCModel::Options::LSB</a> </td><td>Chebyshev model range bounder. </td></tr>
<tr>
<th><code>BOUNDER_ORDER</code> </th><td><code>unsigned int</code> </td><td>0 </td><td>Order of Bernstein polynomial for Chebyshev model range bounding, when mc::SCModel::options::BOUNDER_TYPE = mc::SCModel::options::BERNSTEIN is selected. Only values greater than the actual Chebyshev model order are accounted for; see [Lin &amp; Rokne, 1996]. </td></tr>
<tr>
<th><code>REF_POLY</code> </th><td><code>double</code> </td><td>0. </td><td>Scalar in \([0,1]\) related to the choice of the polynomial part in the overloaded functions mc::inter and mc::hull (see <a class="el" href="page_CHEBYSHEV.html#sec_CHEBYSHEV_fct">Which functions are overloaded for Chebyshev model arithmetic?</a>). A value of 0. amounts to selecting the polynomial part of the left operand, whereas a value of 1. selects the right operand. </td></tr>
<tr>
<th><code>DISPLAY_DIGITS</code> </th><td><code>unsigned int</code> </td><td>5 </td><td>Number of digits in output stream for Chebyshev model coefficients. </td></tr>
</table>
<h1><a class="anchor" id="sec_CM_err"></a>
Errors What errors can I encounter during computation of a Chebyshev model?</h1>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, a class object of type <a class="el" href="classmc_1_1SCModel_1_1Exceptions.html" title="Exceptions of mc::SCModel. ">mc::SCModel::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during the computation of a Chebyshev model, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, the execution will abort.</p>
<p>Possible errors encountered during the computation of a Chebyshev model are:</p>
<a class="anchor" id=""></a>
<table  border="1">
<caption><em>Errors during the Computation of a Chebyshev Model</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Division by zero </td></tr>
<tr>
<th><code>2</code> </th><td>Failed to compute eigenvalue decomposition in range bounder SCModel::Options::EIGEN </td></tr>
<tr>
<th><code>3</code> </th><td>Failed to compute the maximum gap between a univariate term and its Bernstein model </td></tr>
<tr>
<th><code>-1</code> </th><td>Number of variable in Chebyshev model must be nonzero </td></tr>
<tr>
<th><code>-2</code> </th><td>Failed to construct Chebyshev variable </td></tr>
<tr>
<th><code>-3</code> </th><td>Chebyshev model bound does not intersect with bound in template parameter arithmetic </td></tr>
<tr>
<th><code>-4</code> </th><td>Operation between Chebyshev variables linked to different Chebyshev models </td></tr>
<tr>
<th><code>-5</code> </th><td>Maximum size of Chebyshev model reached (monomials indexed as unsigned int) </td></tr>
<tr>
<th><code>-33</code> </th><td>Feature not yet implemented in <a class="el" href="classmc_1_1SCModel.html" title="C++ class for the computation of sparse Chebyshev models for factorable function: environment...">mc::SCModel</a> </td></tr>
</table>
<p>Moreover, exceptions may be thrown by the template parameter class itself.</p>
<h1><a class="anchor" id="sec_CM_refs"></a>
References</h1>
<ul>
<li>Brisebarre, N., and M. Joldes, <a href="http://hal.archives-ouvertes.fr/docs/00/48/17/37/PDF/RRLIP2010-13.pdf">Chebyshev Interpolation Polynomial-based Tools for Rigorous Computing</a>, <em>Research Report No RR2010-13</em>, Ecole Normale Suprieure de Lyon, Unit Mixte de Recherche CNRS-INRIA-ENS LYON-UCBL No 5668, 2010</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 1 2017 01:17:05 for MC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
